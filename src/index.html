<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <form>
      <select name="" id="select">
        <option value="1">куб</option>
        <option value="2">пирамида</option>
        <option value="3">шар</option>
      </select>
      <input type="text" id="inp" placeholder="1,2,3" />
      <button id="btn" type="submit">create</button>
    </form>

    <div
      style="position: absolute; left:0; bottom:0; z-index: 999"
      id="uid"
    ></div>
    <script type="module">
      import * as THREE from "../node_modules/three/build/three.module.js";

      import { OrbitControls } from "../node_modules/three/examples/jsm/controls/OrbitControls.js";
      // var OrbitControls = require("../node_modules/three-orbitcontrols/OrbitControls.js");

      let figure;

      var camera, controls, scene, renderer;

      init();
      //render(); // remove when using next line for animation loop (requestAnimationFrame)
      animate();

      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xcccccc);
        scene.fog = new THREE.FogExp2(0xcccccc, 0.002);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );
        camera.position.set(400, 200, 0);

        // controls

        controls = new OrbitControls(camera, renderer.domElement);

        //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.05;

        controls.screenSpacePanning = false;

        controls.minDistance = 100;
        controls.maxDistance = 500;

        controls.maxPolarAngle = Math.PI / 2;

        // world

        var pyramid = new THREE.CylinderBufferGeometry(0, 10, 30, 4, 1);
        var cube = new THREE.CylinderBufferGeometry(15, 15, 20, 4, 4);
        var boll = new THREE.SphereGeometry(5, 5, 5);
        var material = new THREE.MeshPhongMaterial({
          color: "red",
          flatShading: true
        });

        let shape = 1;
        let [x, y, z] = [1, 1, 1];
        document
          .querySelector("#select")
          .addEventListener("change", function(e) {
            shape = e.target.value;
          });

        document.querySelector("#inp").addEventListener("input", function(e) {
          let arr = e.target.value.trim().split(",");

          if (arr.length > 3) {
            arr = [1, 1, 1];
            alert("введите 3 числа через запятую");
            e.target.value = "";
            return false;
          }
          if (arr[0] > 10 || arr[1] > 10 || arr[2] > 10) {
            arr = [1, 1, 1];
            alert("чисда не должны быть больше 10");
            e.target.value = "";
            return false;
          }
          [x, y, z] = arr;
        });

        document.querySelector("#btn").addEventListener("click", function(e) {
          e.preventDefault();
          switch (true) {
            case shape == 1:
              cube = new THREE.CylinderBufferGeometry(15, 15, 20, 4, 4).scale(
                x,
                y,
                z
              );
              gen(cube);
              break;
            case shape == 2:
              pyramid = new THREE.CylinderBufferGeometry(0, 10, 30, 4, 1).scale(
                x,
                y,
                z
              );
              gen(pyramid);

              break;
            case shape == 3:
              boll = new THREE.SphereGeometry(5, 5, 5).scale(x, y, z);
              gen(boll);
              break;
            // case de
          }
          // [x, y, z] = [1, 1, 1];
        });

        let uid = document.querySelector("#uid");

        let meshArr = [];

        function gen(sh) {
          var mesh = new THREE.Mesh(sh, material);
          mesh.position.x = Math.random() * 100;
          mesh.position.y = 0;
          mesh.position.z = Math.random() * 100;
          mesh.updateMatrix();
          mesh.matrixAutoUpdate = false;
          scene.add(mesh);
          meshArr.push(mesh.uuid);
          uid.innerHTML = meshArr
            .map(function(el) {
              return `<p id="${el}">${el}</p>`;
            })
            .join("");
        }

        uid.addEventListener("click", function({ target }) {
          let obj = {};
          scene.children.map(function(el) {
            target.remove();
            el.uuid === target.id ? (obj = el) : el;
          });
          scene.remove(obj);
        });

        // lights

        var light = new THREE.DirectionalLight(0xffffff);
        light.position.set(1, 1, 1);
        scene.add(light);

        var light = new THREE.DirectionalLight(0x002288);
        light.position.set(-1, -1, -1);
        scene.add(light);

        var light = new THREE.AmbientLight(0x222222);
        scene.add(light);

        //

        window.addEventListener("resize", onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

        render();
      }

      function render() {
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
